--[[ This is my Kart system.

For the handling, i'm modifying physicalproperties of the wheels so that when the user drifts,
 the rear wheels slides out, but some grip is still on the front , so you can still steer into the turn. 
 
 For drifting, i tried lowering friction to get that mario kart driving feeling,
 but it wasn't enough, so I used VectorForce and AngularVelocity to push the kart sideways and
 rotate it. I used those to calculate the force based on how fast the kart goes, to avoid spinning out.
 
 I used a custom function for the steering visuals, so that it looks like the wheels of the kart
 rotates the shortest distance and not snapping the long way around.
]]


-- Services
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- References
local Kart = script.Parent
local Core = Kart:WaitForChild("Core")
local Seat = Core:WaitForChild("VehicleSeat")
local Body = Core.Body
local DriftingVal = Core:WaitForChild("Drifting")
local WheelsFolder = Kart:WaitForChild("Wheels")

-- External Data
local KartModule = require(ReplicatedStorage.Modules.KartData)
local Stats = KartModule[Kart.Name]

-- Tuning & Constants
local topSpeed = Stats.TopSpeed
local acceleration = Stats.Acceleration
local steerAngle = Stats.SteerAngle
local handlingMult = Stats.Handling or 1.0

local driftTurnSpeed = 3.5 * handlingMult
local driftSlidePower = 16000 / handlingMult
local driftBoostReqTime = 1.2
local driftBoostPower = 12000
local driftBoostDuration = 0.6
local minDriftSpeed = 25

-- Physics Properties
local normalFrontProps = PhysicalProperties.new(2, 1.2, 0, 1, 0)
local normalRearProps = PhysicalProperties.new(2, 1.6, 0, 1, 0)
local driftFrontProps = PhysicalProperties.new(2, 0.8, 0, 1, 0)
local driftRearProps = PhysicalProperties.new(2, 0.8 * handlingMult, 0, 1, 0)

-- State
local raceActive = false
local lastOccupant = nil
local driftStartTime = 0
local isDrifting = false

-- Wheel Setup
local motors = {
	FRM = WheelsFolder.Hinges.WheelFR,
	FLM = WheelsFolder.Hinges.WheelFL,
	BRM = WheelsFolder.Hinges.WheelRR,
	BLM = WheelsFolder.Hinges.WheelRL
}

local originalOrientations = {
	FRM = motors.FRM.Attachment0.Orientation,
	FLM = motors.FLM.Attachment0.Orientation
}

-- Apply torque settings
for _, motor in pairs(motors) do
	motor.MotorMaxTorque = acceleration * 3
end

local wheelColliders = {
	FL = WheelsFolder.FL.WheelCollider,
	FR = WheelsFolder.FR.WheelCollider,
	RL = WheelsFolder.RL.WheelCollider,
	RR = WheelsFolder.RR.WheelCollider
}

-- Init Friction
wheelColliders.FL.CustomPhysicalProperties = normalFrontProps
wheelColliders.FR.CustomPhysicalProperties = normalFrontProps
wheelColliders.RL.CustomPhysicalProperties = normalRearProps
wheelColliders.RR.CustomPhysicalProperties = normalRearProps

-- Suspension & Stability Setup
local function createForce(name, className, parent, props)
	local obj = Instance.new(className)
	obj.Name = name
	for k, v in pairs(props) do
		obj[k] = v
	end
	obj.Parent = parent
	return obj
end

-- Center of Mass adjustment (Ballast)
local ballast = Instance.new("Part")
ballast.Name = "Ballast"
ballast.Size = Vector3.new(2, 0.5, 3)
ballast.Transparency = 1
ballast.CanCollide = false
ballast.Massless = false
ballast.CFrame = Body.CFrame * CFrame.new(0, -1.5, 0)
ballast.Parent = Kart

local weld = Instance.new("WeldConstraint")
weld.Part0 = Body
weld.Part1 = ballast
weld.Parent = ballast

-- Stabilization Forces
local airAtt = Instance.new("Attachment", Body)
local driftAtt = Instance.new("Attachment", Body)

local airStabilizer = createForce("AirStabilizer", "AlignOrientation", Body, {
	Attachment0 = airAtt,
	Mode = Enum.OrientationAlignmentMode.OneAttachment,
	RigidityEnabled = false,
	Responsiveness = 5,
	MaxTorque = 50000,
	Enabled = false
})

local airFloatForce = createForce("AirFloatForce", "VectorForce", Body, {
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Attachment0 = airAtt,
	Enabled = false
})

local driftSlideForce = createForce("DriftSlideForce", "VectorForce", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Enabled = false
})

local driftTurnAssist = createForce("DriftTurnAssist", "AngularVelocity", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	MaxTorque = 200000,
	Enabled = false
})

local boostForce = createForce("DriftBoostForce", "VectorForce", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Enabled = false
})

-- Raycasting for Air Time
local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {Kart}
rayParams.FilterType = Enum.RaycastFilterType.Exclude

local function checkIsAirborne()
	return Workspace:Raycast(Body.Position, Vector3.new(0, -6, 0), rayParams) == nil
end

-- Math Helper (Lerp angle via shortest path)
local function shortPathLerp(current, target, alpha)
	local diff = (target - current)
	local corrected = Vector3.new(
		(diff.X + 180) % 360 - 180, 
		(diff.Y + 180) % 360 - 180, 
		(diff.Z + 180) % 360 - 180
	)
	return current + corrected * alpha
end

-- Race Start Logic
task.spawn(function()
	task.wait(3) 
	-- Simple countdown log
	for i = 3, 1, -1 do
		print("Starting in...", i)
		task.wait(1)
	end
	print("GO!")
	raceActive = true
end)

-- Main Physics Loop
RunService.Heartbeat:Connect(function(dt)
	dt = math.min(dt, 0.1) -- Prevent physics explosions on lag spikes

	if not raceActive then
		for _, motor in pairs(motors) do
			motor.AngularVelocity = 0
		end
		return
	end

	local throttle = Seat.Throttle
	local steer = Seat.Steer
	local speed = Body.AssemblyLinearVelocity.Magnitude

	-- Air Mechanics
	if checkIsAirborne() then
		local vel = Body.AssemblyLinearVelocity
		local look = Body.CFrame.LookVector

		-- Align car to velocity if moving fast, otherwise keep flat
		local targetCF = (vel.Magnitude > 10) 
			and CFrame.lookAt(Body.Position, Body.Position + vel)
			or CFrame.lookAt(Body.Position, Body.Position + Vector3.new(look.X, 0, look.Z))

		airStabilizer.CFrame = targetCF
		airStabilizer.Enabled = true

		-- Gravity compensation (hang time)
		airFloatForce.Force = Vector3.new(0, Body.AssemblyMass * Workspace.Gravity * 0.55, 0)
		airFloatForce.Enabled = true

		driftSlideForce.Enabled = false
		driftTurnAssist.Enabled = false
	else
		airStabilizer.Enabled = false
		airFloatForce.Enabled = false

		-- Drift Mechanics
		local isMovingForward = throttle > -0.1
		local steerMag = math.abs(steer)
		local speedRatio = math.clamp((speed - minDriftSpeed) / 50, 0, 1)

		-- Check drift conditions
		if DriftingVal.Value and speed > minDriftSpeed and isMovingForward and steerMag > 0.1 then
			driftTurnAssist.Enabled = true
			driftSlideForce.Enabled = true

			if not isDrifting then
				isDrifting = true
				driftStartTime = tick()
			end

			local vel = Body.AssemblyLinearVelocity
			local flatVel = Vector3.new(vel.X, 0, vel.Z)

			-- Apply sideways force to simulate losing grip
			local forceDir
			if flatVel.Magnitude > 1 then
				local moveRight = flatVel.Unit:Cross(Vector3.new(0, 1, 0))
				forceDir = moveRight * steer
			else
				forceDir = Body.CFrame.RightVector * -steer
			end

			driftSlideForce.Force = forceDir * (driftSlidePower * speedRatio)
			driftTurnAssist.AngularVelocity = Body.CFrame.UpVector * (-steer * driftTurnSpeed * speedRatio)
		else
			driftTurnAssist.Enabled = false
			driftSlideForce.Enabled = false
			isDrifting = false
		end
	end

	-- Engine Output
	local powerFactor = (DriftingVal.Value or math.abs(steer) < 0.7) and 1 or 0.8

	for _, motor in pairs(motors) do
		local targetVel = topSpeed * (-throttle) * powerFactor
		if motor:HasTag("Reverse") then targetVel *= -1 end
		motor.AngularVelocity = targetVel
	end

	-- Visual Steering
	if Seat.Occupant then
		local speedFactor = 1 / (1 + (speed * 0.045))
		local maxInput = (DriftingVal.Value or speed < 40) and 1.0 or (speed < 80 and 0.7 or 0.45)

		local finalSteer = math.clamp(steer, -maxInput, maxInput) * speedFactor
		local angle = steerAngle * (DriftingVal.Value and 1.5 or 1.0) * finalSteer
		local alpha = math.clamp(dt * 16, 0, 1) -- Steer response speed

		motors.FLM.Attachment0.Orientation = shortPathLerp(motors.FLM.Attachment0.Orientation, originalOrientations.FLM - Vector3.new(0, angle, 0), alpha)
		motors.FRM.Attachment0.Orientation = shortPathLerp(motors.FRM.Attachment0.Orientation, originalOrientations.FRM - Vector3.new(0, angle, 0), alpha)
	end
end)

-- Drift Input & Boost Logic
DriftingVal.Changed:Connect(function(isDriftingInput)
	if isDriftingInput then
		-- Cut friction for drift feel
		wheelColliders.FL.CustomPhysicalProperties = driftFrontProps
		wheelColliders.FR.CustomPhysicalProperties = driftFrontProps
		wheelColliders.RL.CustomPhysicalProperties = driftRearProps
		wheelColliders.RR.CustomPhysicalProperties = driftRearProps

		isDrifting = true
		driftStartTime = tick()
	else
		-- Restore friction
		wheelColliders.FL.CustomPhysicalProperties = normalFrontProps
		wheelColliders.FR.CustomPhysicalProperties = normalFrontProps
		wheelColliders.RL.CustomPhysicalProperties = normalRearProps
		wheelColliders.RR.CustomPhysicalProperties = normalRearProps

		-- Calculate Boost
		if isDrifting and (tick() - driftStartTime >= driftBoostReqTime) then
			local vel = Body.AssemblyLinearVelocity
			local flatVel = Vector3.new(vel.X, 0, vel.Z)

			boostForce.Force = (flatVel.Magnitude > 1 and flatVel.Unit or Body.CFrame.LookVector) * driftBoostPower
			boostForce.Enabled = true

			-- VFX Trigger
			local boostVFX = Core.Body:FindFirstChild("Boost")
			if boostVFX then boostVFX.Boost1.Enabled = true end

			task.delay(driftBoostDuration, function()
				boostForce.Enabled = false
				if boostVFX then boostVFX.Boost1.Enabled = false end
			end)
		end
		isDrifting = false
	end
end)

-- UI Connection
Seat:GetPropertyChangedSignal("Occupant"):Connect(function()
	local occupant = Seat.Occupant
	if occupant then
		local player = Players:GetPlayerFromCharacter(occupant.Parent)
		if player then
			lastOccupant = player
			-- Clone UI elements
			for _, assetName in pairs({"DriftController", "MainHUD"}) do
				local ui = ReplicatedStorage.Assets[assetName]:Clone()
				local objVal = ui:FindFirstChildWhichIsA("ObjectValue")
				if objVal then objVal.Value = Kart end
				ui.Parent = player.PlayerGui
			end
		end
	elseif lastOccupant then
		-- Cleanup UI
		for _, uiName in pairs({"DriftController", "MainHUD"}) do
			local ui = lastOccupant.PlayerGui:FindFirstChild(uiName)
			if ui then ui:Destroy() end
		end
		lastOccupant = nil
	end
end)
