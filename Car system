--[[ This is my Kart system.

For the handling, i'm modifying physicalproperties of the wheels so that when the user drifts,
 the rear wheels slides out, but some grip is still on the front , so you can still steer into the turn. 
 
 For drifting, i tried lowering friction to get that mario kart driving feeling,
 but it wasn't enough, so I used VectorForce and AngularVelocity to push the kart sideways and
 rotate it. I used those to calculate the force based on how fast the kart goes, to avoid spinning out.
 
 I used a custom function for the steering visuals, so that it looks like the wheels of the kart
 rotates the shortest distance and not snapping the long way around.

For the state: I made variables to prevent the kart from moving before the countdown finishes. raceActive stops the kart from moving before the countdown is over,
and driftStartTime / isDrifting calculates if the player held the drifting long enough to gain a speed boost.

For WheelSetup: I listed the hinge constraints in a table , so I can loop through them later. I get the Original Orientations of the front wheel attachments,
so that when I steer the kart it rotates relative to a particular point. Like in mario kart, the kart is at an angle when drifting.

For ApplyTorque settings: This controls how easy it is for the kart to move. I set a high MotorMaxTorque based on acceleration. If its too low, the kart will have
issues climbing up steep ramps or might even have issues moving at all. If it's high physics glitches might happen. So I just tried to make the wheels to be strong
enough for the kart to move.

For Wheel Colliders & Friction: I applied normalFrontProps and normalRearProps so that the baseline grip has high friction, so that the kart drives normally and
doesn't slide uncontrollably, unless drifting is enabled.

For Suspension & Stability: It's just a helper function I made for efficiency, so that I don't have to write new lines of code everytime I need a new physics force.
So I just pass the data into the function to create them in one go.

For Center of Mass: I created a part and named it Ballast. Its just to lower the center of gravity so that the kart stays glued to the floor and doesn't flip over
when you hit a wall at full speed or smth.

For Stabilization Forces: These are helper funcs that make the driving feel arcadish in a way, rather than realistic.
AirStabilizer forces the kart to stay upright when it goes off a ramp, so the kart doesn't nose-down upon landing.
AirFloatForce basically just cancels out gravity a little bit so that going off a ramp feels floaty.
DriftSlideTurnAssist pushes the karts body sideways and rotates it when drifting for visuals.

Raycast for AirTime is just to check if the kart is on the ground. I shoot a ray like 6 studs down, and if it hits nothing, then the kart is in the air.

Math Helper (short path lerp) is just to ensure that the rotation takes the shortest path across the 0/360 boundary, so the wheels don't snap

The main physics loop.
Air Mechanics is just to see if the kart is in the air, then I align the kart's orientation to where its moving and turn on the float force.
Drift Mechanics is to check if the kart is on the ground and if the drift button is held, then I calculate a VectorForce to push the kart sideways (driftSlideForce)
based on how hard I'm steering the kart.
Engine Output is for applying AngularVelocity to the wheel hinges to drive the kart forward.
Visual Steering. I decoupled the visual  wheel rotation from the physics, then used a lerp function to make the wheels turn smoothly , so it doesn't snap weirdly
to the input.

Drift Input/Boost logic listens for the drift key.
For Pressed. I swap the wheel physical properties to make it slippery so that the physics let's the kart slide.
For Released. I swap back to high friction, then check tick() - driftStartTime. if the player drifted longer than driftBoostReqTime, i fire the boostForce to make
the kart shoot forward.

For UI Connection. It's just when a player sits in the VehicleSeat, I clone the speedometer/Drift ui into their playerGui, then when they jump out, I delete it.
]]


-- Services
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- References
local Kart = script.Parent
local Core = Kart:WaitForChild("Core")
local Seat = Core:WaitForChild("VehicleSeat")
local Body = Core.Body
local DriftingVal = Core:WaitForChild("Drifting")
local WheelsFolder = Kart:WaitForChild("Wheels")

-- External Data
local KartModule = require(ReplicatedStorage.Modules.KartData)
local Stats = KartModule[Kart.Name]

-- Tuning & Constants
local topSpeed = Stats.TopSpeed
local acceleration = Stats.Acceleration
local steerAngle = Stats.SteerAngle
local handlingMult = Stats.Handling or 1.0

local driftTurnSpeed = 3.5 * handlingMult
local driftSlidePower = 16000 / handlingMult
local driftBoostReqTime = 1.2
local driftBoostPower = 12000
local driftBoostDuration = 0.6
local minDriftSpeed = 25

-- Physics Properties
local normalFrontProps = PhysicalProperties.new(2, 1.2, 0, 1, 0)
local normalRearProps = PhysicalProperties.new(2, 1.6, 0, 1, 0)
local driftFrontProps = PhysicalProperties.new(2, 0.8, 0, 1, 0)
local driftRearProps = PhysicalProperties.new(2, 0.8 * handlingMult, 0, 1, 0)

-- State
local raceActive = false
local lastOccupant = nil
local driftStartTime = 0
local isDrifting = false

-- Wheel Setup
local motors = {
	FRM = WheelsFolder.Hinges.WheelFR,
	FLM = WheelsFolder.Hinges.WheelFL,
	BRM = WheelsFolder.Hinges.WheelRR,
	BLM = WheelsFolder.Hinges.WheelRL
}

local originalOrientations = {
	FRM = motors.FRM.Attachment0.Orientation,
	FLM = motors.FLM.Attachment0.Orientation
}

-- Apply torque settings
for _, motor in pairs(motors) do
	motor.MotorMaxTorque = acceleration * 3
end

local wheelColliders = {
	FL = WheelsFolder.FL.WheelCollider,
	FR = WheelsFolder.FR.WheelCollider,
	RL = WheelsFolder.RL.WheelCollider,
	RR = WheelsFolder.RR.WheelCollider
}

-- Init Friction
wheelColliders.FL.CustomPhysicalProperties = normalFrontProps
wheelColliders.FR.CustomPhysicalProperties = normalFrontProps
wheelColliders.RL.CustomPhysicalProperties = normalRearProps
wheelColliders.RR.CustomPhysicalProperties = normalRearProps

-- Suspension & Stability Setup
local function createForce(name, className, parent, props)
	local obj = Instance.new(className)
	obj.Name = name
	for k, v in pairs(props) do
		obj[k] = v
	end
	obj.Parent = parent
	return obj
end

-- Center of Mass adjustment (Ballast)
local ballast = Instance.new("Part")
ballast.Name = "Ballast"
ballast.Size = Vector3.new(2, 0.5, 3)
ballast.Transparency = 1
ballast.CanCollide = false
ballast.Massless = false
ballast.CFrame = Body.CFrame * CFrame.new(0, -1.5, 0)
ballast.Parent = Kart

local weld = Instance.new("WeldConstraint")
weld.Part0 = Body
weld.Part1 = ballast
weld.Parent = ballast

-- Stabilization Forces
local airAtt = Instance.new("Attachment", Body)
local driftAtt = Instance.new("Attachment", Body)

local airStabilizer = createForce("AirStabilizer", "AlignOrientation", Body, {
	Attachment0 = airAtt,
	Mode = Enum.OrientationAlignmentMode.OneAttachment,
	RigidityEnabled = false,
	Responsiveness = 5,
	MaxTorque = 50000,
	Enabled = false
})

local airFloatForce = createForce("AirFloatForce", "VectorForce", Body, {
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Attachment0 = airAtt,
	Enabled = false
})

local driftSlideForce = createForce("DriftSlideForce", "VectorForce", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Enabled = false
})

local driftTurnAssist = createForce("DriftTurnAssist", "AngularVelocity", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	MaxTorque = 200000,
	Enabled = false
})

local boostForce = createForce("DriftBoostForce", "VectorForce", Body, {
	Attachment0 = driftAtt,
	RelativeTo = Enum.ActuatorRelativeTo.World,
	Enabled = false
})

-- Raycasting for Air Time
local rayParams = RaycastParams.new()
rayParams.FilterDescendantsInstances = {Kart}
rayParams.FilterType = Enum.RaycastFilterType.Exclude

local function checkIsAirborne()
	return Workspace:Raycast(Body.Position, Vector3.new(0, -6, 0), rayParams) == nil
end

-- Math Helper (Lerp angle via shortest path)
local function shortPathLerp(current, target, alpha)
	local diff = (target - current)
	local corrected = Vector3.new(
		(diff.X + 180) % 360 - 180, 
		(diff.Y + 180) % 360 - 180, 
		(diff.Z + 180) % 360 - 180
	)
	return current + corrected * alpha
end

-- Race Start Logic
task.spawn(function()
	task.wait(3) 
	-- Simple countdown log
	for i = 3, 1, -1 do
		print("Starting in...", i)
		task.wait(1)
	end
	print("GO!")
	raceActive = true
end)

-- Main Physics Loop
RunService.Heartbeat:Connect(function(dt)
	dt = math.min(dt, 0.1) -- Prevent physics explosions on lag spikes

	if not raceActive then
		for _, motor in pairs(motors) do
			motor.AngularVelocity = 0
		end
		return
	end

	local throttle = Seat.Throttle
	local steer = Seat.Steer
	local speed = Body.AssemblyLinearVelocity.Magnitude

	-- Air Mechanics
	if checkIsAirborne() then
		local vel = Body.AssemblyLinearVelocity
		local look = Body.CFrame.LookVector

		-- Align car to velocity if moving fast, otherwise keep flat
		local targetCF = (vel.Magnitude > 10) 
			and CFrame.lookAt(Body.Position, Body.Position + vel)
			or CFrame.lookAt(Body.Position, Body.Position + Vector3.new(look.X, 0, look.Z))

		airStabilizer.CFrame = targetCF
		airStabilizer.Enabled = true

		-- Gravity compensation (hang time)
		airFloatForce.Force = Vector3.new(0, Body.AssemblyMass * Workspace.Gravity * 0.55, 0)
		airFloatForce.Enabled = true

		driftSlideForce.Enabled = false
		driftTurnAssist.Enabled = false
	else
		airStabilizer.Enabled = false
		airFloatForce.Enabled = false

		-- Drift Mechanics
		local isMovingForward = throttle > -0.1
		local steerMag = math.abs(steer)
		local speedRatio = math.clamp((speed - minDriftSpeed) / 50, 0, 1)

		-- Check drift conditions
		if DriftingVal.Value and speed > minDriftSpeed and isMovingForward and steerMag > 0.1 then
			driftTurnAssist.Enabled = true
			driftSlideForce.Enabled = true

			if not isDrifting then
				isDrifting = true
				driftStartTime = tick()
			end

			local vel = Body.AssemblyLinearVelocity
			local flatVel = Vector3.new(vel.X, 0, vel.Z)

			-- Apply sideways force to simulate losing grip
			local forceDir
			if flatVel.Magnitude > 1 then
				local moveRight = flatVel.Unit:Cross(Vector3.new(0, 1, 0))
				forceDir = moveRight * steer
			else
				forceDir = Body.CFrame.RightVector * -steer
			end

			driftSlideForce.Force = forceDir * (driftSlidePower * speedRatio)
			driftTurnAssist.AngularVelocity = Body.CFrame.UpVector * (-steer * driftTurnSpeed * speedRatio)
		else
			driftTurnAssist.Enabled = false
			driftSlideForce.Enabled = false
			isDrifting = false
		end
	end

	-- Engine Output
	local powerFactor = (DriftingVal.Value or math.abs(steer) < 0.7) and 1 or 0.8

	for _, motor in pairs(motors) do
		local targetVel = topSpeed * (-throttle) * powerFactor
		if motor:HasTag("Reverse") then targetVel *= -1 end
		motor.AngularVelocity = targetVel
	end

	-- Visual Steering
	if Seat.Occupant then
		local speedFactor = 1 / (1 + (speed * 0.045))
		local maxInput = (DriftingVal.Value or speed < 40) and 1.0 or (speed < 80 and 0.7 or 0.45)

		local finalSteer = math.clamp(steer, -maxInput, maxInput) * speedFactor
		local angle = steerAngle * (DriftingVal.Value and 1.5 or 1.0) * finalSteer
		local alpha = math.clamp(dt * 16, 0, 1) -- Steer response speed

		motors.FLM.Attachment0.Orientation = shortPathLerp(motors.FLM.Attachment0.Orientation, originalOrientations.FLM - Vector3.new(0, angle, 0), alpha)
		motors.FRM.Attachment0.Orientation = shortPathLerp(motors.FRM.Attachment0.Orientation, originalOrientations.FRM - Vector3.new(0, angle, 0), alpha)
	end
end)

-- Drift Input & Boost Logic
DriftingVal.Changed:Connect(function(isDriftingInput)
	if isDriftingInput then
		-- Cut friction for drift feel
		wheelColliders.FL.CustomPhysicalProperties = driftFrontProps
		wheelColliders.FR.CustomPhysicalProperties = driftFrontProps
		wheelColliders.RL.CustomPhysicalProperties = driftRearProps
		wheelColliders.RR.CustomPhysicalProperties = driftRearProps

		isDrifting = true
		driftStartTime = tick()
	else
		-- Restore friction
		wheelColliders.FL.CustomPhysicalProperties = normalFrontProps
		wheelColliders.FR.CustomPhysicalProperties = normalFrontProps
		wheelColliders.RL.CustomPhysicalProperties = normalRearProps
		wheelColliders.RR.CustomPhysicalProperties = normalRearProps

		-- Calculate Boost
		if isDrifting and (tick() - driftStartTime >= driftBoostReqTime) then
			local vel = Body.AssemblyLinearVelocity
			local flatVel = Vector3.new(vel.X, 0, vel.Z)

			boostForce.Force = (flatVel.Magnitude > 1 and flatVel.Unit or Body.CFrame.LookVector) * driftBoostPower
			boostForce.Enabled = true

			-- VFX Trigger
			local boostVFX = Core.Body:FindFirstChild("Boost")
			if boostVFX then boostVFX.Boost1.Enabled = true end

			task.delay(driftBoostDuration, function()
				boostForce.Enabled = false
				if boostVFX then boostVFX.Boost1.Enabled = false end
			end)
		end
		isDrifting = false
	end
end)

-- UI Connection
Seat:GetPropertyChangedSignal("Occupant"):Connect(function()
	local occupant = Seat.Occupant
	if occupant then
		local player = Players:GetPlayerFromCharacter(occupant.Parent)
		if player then
			lastOccupant = player
			-- Clone UI elements
			for _, assetName in pairs({"DriftController", "MainHUD"}) do
				local ui = ReplicatedStorage.Assets[assetName]:Clone()
				local objVal = ui:FindFirstChildWhichIsA("ObjectValue")
				if objVal then objVal.Value = Kart end
				ui.Parent = player.PlayerGui
			end
		end
	elseif lastOccupant then
		-- Cleanup UI
		for _, uiName in pairs({"DriftController", "MainHUD"}) do
			local ui = lastOccupant.PlayerGui:FindFirstChild(uiName)
			if ui then ui:Destroy() end
		end
		lastOccupant = nil
	end
end)
